%!TEX root = fusion.tex

Recursion schemes are almost everywhere in functional programming. They generalize mainly two very common patterns: constructing a structure and destructing it recursively. They were popularized by Meijer et al. \cite{4cec4a43c86444479dc0003182424795}, which are giving them a categorical meaning. Our goal is not to study these strong mathematical foundations, but just define and use recursive schemes on a particular case: fixed-point types.

\subsection{Fixed-point types}
\label{subsec:defi}
First of all, classic recursive structure can be defined as \emph{fixed-points}, using the \hs{Fix} data-type:
\begin{minted}{Haskell}
newtype Fix f = Fix (f (Fix f))
\end{minted}
\hs{Fix} directly encodes recursion in types: you are giving to a parametric type itself, again and again. Note that this data-type is defined with \hs{newtype} (and not simply with a \hs{type} synonym) since it calls itself, but the great work of Breitner et al. \cite{Breitner:2014:SZC:2692915.2628141} will optimize it away at compile time.

For example, you can define, as in figure \ref{fig:listtree}
\hs{(List a)}, isomorphic to \hs{[a]} and \hs{(Tree a)}, isomorphic to the classic recursive structure for binary trees:
\begin{minted}{Haskell}
data TreeB a =
    Empty
  | Leaf a
  | Node (Tree a) (Tree a)
\end{minted}

\begin{figure}
\begin{minted}{Haskell}
data ListF a b =
    NilF
  | ConsF a b

instance Functor (ListF a) where
  fmap _ NilF        = Nil
  fmap f (ConsF a b) = Cons a (f b)

type List a = Fix (List a)

nil :: List a
nil = Fix NilF

cons :: a -> List a -> List a
cons x xs = Fix (ConsF x xs)

data TreeF a b =
    EmptyF
  | LeafF a
  | NodeF b b

instance Functor (TreeF a) where
  fmap _ EmptyF      = EmptyF
  fmap _ (LeafF x)   = LeafF x
  fmap f (NodeF a b) = NodeF (f a) (f b)

type Tree a = Fix (TreeF a)
\end{minted}
\caption{Examples of recursive types: lists and binary trees}
\label{fig:listtree}
\end{figure}

\subsection{Catamorphisms}
A \emph{catamorphism} generalizes a fold on a recursive structure. For example, catamorphisms on lists can be expressed with the so-called \hs{foldr}.
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z []     = z
foldr k z (y:ys) = k y (foldr k z ys)
\end{minted}
The idea of \hs{foldr} is that, if you provide a definition for the empty list and another for the \verb|cons| operation, then you can go trough a list and destruct it recursively. Note that we didn't use the concept of list but just its constructors; consequently you can use this process for any other recursive type. The definition of a type in term of \hs{Fix} allows a straightforward implementation of \hs{cata}, a high-order function for catamorphisms.

\begin{minted}{Haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata f (Fix x) = f (fmap (cata f) x)
\end{minted}
\noindent How \hs{cata} is working? As any fold on any structure! Given a recursive one, your will firstly destruct any substructure, and then apply a function to the result. The "firstly destruct any substructure" step is performed by using a \hs{Functor} instance: it is the only way to get "inside" the structure, since we don't know how it is made. The combination function can also feel a bit strange but its type says it all: if you have a recursive structure where the substructures were replaced by a result, then you must be able to combine these to produce yourself a result.

For example, with \hs{(List a)} from the above example, one can write \hs{foldr}:
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> List a -> b
foldr c e = cata go
  where
    go NilF = e
    go (ConsF a b) = c a b
\end{minted}

\noindent There is a better implementation of \hs{cata} using the same definitions as E. Kmett in his \verb|recusrion-schemes| package \cite{ekmett:eschems}:

\begin{minted}{Haskell}
cata :: Functor f => (f b -> b) -> Fix f -> b
cata f = c where c (Fix x) = f (fmap c x)
\end{minted}

\noindent
where the recursive step was specialized to the \hs{f} argument.

\subsection{Anamorphisms}
An \emph{anamorphism} generalizes the notion of unfolding a recursive structure, that is, producing a structure from a seed value.
For example, anamorphisms on lists can be expressed with the so-called \hs{unfoldr}.
\begin{minted}{Haskell}
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr f b =
  case f b of
    Just (a, b') -> c a (unfoldr f b')
    Nothing      -> n
\end{minted}

\noindent \hs{unfoldr} takes a function that, from a starting seed, produces maybe an element and another seed, or nothing. As clever reader already guessed, we can provide anamorphisms for any fixed-point structure, using:
\begin{minted}{Haskell}
ana :: Functor f => (b -> f b) -> b -> Fix f
ana f b = c where c = Fix . fmap c . f
\end{minted}
The first argument is a function that, from a seed, produce a base structure filled with seeds. Then you can iterate the process and obtain a full structure. For example, with lists we can write \hs{unfoldr} in term of \hs{ana}.
\begin{minted}{Haskell}
unfoldr :: (b -> Maybe (a, b)) -> b -> List a
unfoldr f = ana go . f
  where
    go Nothing      = NilF
    go (Just (a,b)) = ConsF a (f b)
\end{minted}

\subsection{Fusion of recursive schemes - hylomorphisms}
A first nice result on these recursive schemes is that the composition of an anamorphism with a catamorphism can be optimized to remove the need of building the intermediate structure: we then obtain a \emph{hylomorphism} (this is correctly proved by Meijer et al. \cite{4cec4a43c86444479dc0003182424795}).
Hylomorphisms can be expressed using \hs{hylo} (as in the \verb|recursion-schemes| package \cite{ekmett:eschems}):
\begin{minted}{Haskell}
hylo :: Functor f =>
  (f b -> b) -> (a -> f a) -> a -> b
hylo f g = h where h = f . fmap h . g
\end{minted}
\noindent \hs{g} generates a structure, destructed right away using \hs{f}.
The goal of the next section is to make this fusion automatically.