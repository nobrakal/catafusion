%!TEX root = fusion.tex
\subsection{Paramorphisms}
\label{sec:para-list}

As far as we did, we worked only on catamorphisms. These are not really satisfying to define recursive functions that also use the unconsumed part of the structure. A \emph{paramorphism} (introduced by Meertens \cite{Meertens1992}) are a direct response, as it allows the combination function to have a look on the unconsumed part of the structure (imitating the full power of recursion).

They can be defined for lists using \minline{para}
\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para _ z []     = z
para k z (x:xs) = k x xs (para k z xs)
\end{minted}

Again, we can also express paramorphisms with types defined in terms of \minline{Fix}, but using a little trick: The usual way (as in the \verb|recursion-schemes| package \cite{ekmett:eschems}) is with \minline{para}:
\begin{minted}{Haskell}
para :: Functor f =>
  (f (Fix f, a) -> a) -> Fix f -> a
para f = c
  where
    c (Fix x) = f (fmap (\y -> (y,p y)) x)
\end{minted}

\noindent What is happening here? As with \minline{cata}, when we are trying to destruct a recursive structure, we are doing the recursive step plus giving a copy of the original data.
For example, we can encode a classic paramorphism, which is giving the list of proper suffixes of a list:
\begin{minted}{Haskell}
suff :: List a -> List (List a)
suff = para go
  where
    go NilF = nil
    go (ConsF x (xs,b)) = cons (cons x xs) b
\end{minted}

\subsection{Fusion for paramorphisms}

Now consider the less trivial paramorphism \minline{has2Leaves} which search in a binary tree if there is two distinct leaves defined in figure \ref{fig:has2Leaves}.

Imagine you are composing it with a \minline{mapt} operation (as defined in section \ref{fig:has2Leaves}). Then
the function:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v f = has2leaves u v . maptf
\end{minted}
\noindent is equivalent to:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v t f = Edge == para go t
  where
    go EmptyF    = Miss
    go (LeafF x) =
      if f x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if cata go' b then Edge else Tail
        Edge -> Edge
    go' EmptyF      = False
    go' (LeafF x)   = f x == v
    go' (NodeF a b) = a || b
\end{minted}

Can we generalize the work made in section \ref{sec:rectypes} to make this work? The answer is yes (section \ref{sec:para-impl}), but we first need to really se what we just made.

\begin{figure}
\begin{minted}{Haskell}
data Hit = Miss | Tail | Edge
  deriving (Eq, Ord, Show)

hasLeaf :: Eq a => a -> Tree a -> Bool
hasLeaf s = cata go
  where
    go EmptyF      = False
    go (LeafF x)   = x == s
    go (NodeF a b) = a || b

has2Leaves :: Eq a => a -> a -> Tree a -> Bool
has2Leaves u v = (==) Edge . para go
  where
    go EmptyF = Miss
    go (LeafF x) =
      if x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if hasLeaf v b then Edge else Tail
        Edge -> Edge

mapt :: (a -> b) -> Tree a -> Tree b
mapt f t = bind t (\x -> fix (LeafF f x))
\end{minted}
\caption{Functions on trees}
\label{fig:has2Leaves}
\end{figure}

\subsection{Usability and validity}
As noticed DomÃ­nguez et al. \cite{paramorphismFusion} fusing paramorphisms with other things is not always a good idea. Consider the previous example with proper suffixes of a list, but again composed with a map:
\begin{minted}{Haskell}
suff (map f xs)
\end{minted}
\noindent If we try to fuse the two functions, we have
\begin{minted}{Haskell}
let go x =
  case x of
    NilF -> nil
    ConsF x (xs,b) -> 
      cons (map f (cons x xs)) b
  in para go xs
\end{minted}
\noindent The \minline{map} happen for each suffixes! We clearly not want that.
The problem here is that the combination function used \emph{both} the recursive call and the unconsumed part of the structure, which leads to a duplication of the work.

\subsection{Implementation}
\label{sec:para-impl}

It is well known that every catamorphism is a paramorphism where the combination function just don't use the un-consumed structure. Indeed, you can define \minline{cata} as:
\begin{minted}{Haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata go = para (go . fmap snd)
{-# INLINE cata #-}
\end{minted}

\noindent We can then define a rule that will only target paramorphisms. However, paramorphism fusion is not as classy as the catamorphisms one. This solution implies two main problems:
\begin{itemize}
\item We cannot target \minline{cata coerce}, since \minline{cata} is just \minline{para}. We cannot either target\\ \minline{para (coerce . fmap snd)}, since \minline{fmap} is a class function.

\item It is not compatible with GHC's \minline{build}. This is discussed in section \ref{sec:parabuild}.
\end{itemize}

We consequently choose to target a specific function that represent either a catamorphism or a paramorphism, called \minline{destruct}, defined with according rules in figure \ref{fig:para}. This choice has some consequences, each described below:

\begin{figure}
\begin{minted}{Haskell}
type Combi f a =
  Either (f a -> a) (f (Fix f, a) -> a)
  
type Para f = forall a. Combi f a -> a 

destruct :: Functor f => Combi f a -> Fix f -> a
destruct (Left c)  = cata c
destruct (Right c) = para c
{-# INLINE [1] destruct #-}

buildR :: Functor f => Para f -> Fix f
buildR g = g (Left fix)
{-# INLINE [1] buildR #-}

{-# RULES
"cata/buildR" [~1] forall f (g::Para f).
  cata f (buildR g) = g (Left f)

"para/buildR" [~1] forall f (g::Para f).
  para f (buildR g) = g (Right f)

"destruct/buildR" [~1] forall f (g::Para f).
  destruct f (buildR g) = g f

"cata/id"
  cata coerce = id
#-}
\end{minted}
\caption{The rule system for paramorphism fusion}
\label{fig:para}
\end{figure}

\subsubsection{For the user, the example of bind on binary trees}
Let us take back our \minline{has2leaves}  but composed with a possible previous operation on the tree \emph{that preserved} the structure. It is not difficult that such an operation can be written using \minline{bind}, so let us concentrate ourselves on an expression like:

\begin{minted}{Haskell}
has2Leaves u v (bind t f)
\end{minted}

\noindent For fusion to happen, we need to have \minline{bind} on a re-writeable form for a paramorphism, that is to write it in term of \minline{buildR}. The interesting part comes with the fact that \minline{bind} appears also on its \minline{buildR} form, as you can see in figure \ref{fig:bindbuild}. It is necessary since we need to perform the \minline{bind} operation also on the unconsumed part of the tree if we are fusing with a paramorphism. Since with \minline{has2Leaves} we also destruct the the unconsumed part of the tree using \minline{hasLeaf} (a catamorphism), one can hope that fusion happen here too, so we need this bind to be also in a rewritable form, so we introduce \minline{bindR} which is just \minline{bind} in its \minline{buildR} form.

TODO infinite buildR

\begin{figure}
\begin{minted}{Haskell}
bind :: Tree a -> (a -> Tree b) -> Tree b
bind f t = buildR $ \u -> destruct (
  case u of
    Left u -> Left $ \x -> 
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u $ NodeF a b)
    Right u -> Right $ \x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> para u (f x)
        NodeF (a,a') (b,b') -> u $
          NodeF (bindR f a,a') (bindR f b, b'))
  t

-- This is just bind
bindR :: Tree a -> (a -> Tree b) -> Tree b
bindR f t = buildR $ \u -> destruct (
  case u of
    Left u -> Left $ \x -> 
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u $ NodeF a b)
    Right u -> Right $ \x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> para u (f x)
        NodeF (a,a') (b,b') -> u $
          NodeF (cata go a,a') (cata go b, b'))
  t
  where
    go EmptyF = fix EmptyF
    go (LeafF a) = f a
    go (NodeF a b) = fix (NodeF a b)

\end{minted}
\caption{\minline{bind} in term of \minline{bindR} and \minline{destruct}}
\label{fig:bindbuild}
\end{figure}

\subsubsection{Many rules}
We now have three rules, and we need all of them. Indeed, \verb|"cata/buildR"| and \verb|"para/buildR"| are needed to correctly fuse the two recursion schemes. \verb|"destruct/buildR"| is a rule needed when composing functions: with an expression like
\begin{minted}{Haskell}
bind (bind t f) g
\end{minted}
\noindent the two \minline{bind} will be inlined into their \minline{buildR} form, but since they have to deal with either a paramorphism or a catamorphism, they need to do a case analysis on the destructive function. A possibility is to perform directly the case analysis, but this will duplicate the occurrences of the second \minline{bind} into the body of the first, and GHC is smart enough to create a variable to reduce code duplication, no knowing that this duplication will be optimized after. So we can use \minline{destruct}, and performing the case analysis in its argument. Hence, without a too early inlining of it, the second \minline{bind} appears only once, and we can fuse it using \verb|"destruct/buildR"|.

\subsubsection{Compatibility with GHC's rules on lists}
\label{sec:parabuild}
To be able to fuse eligible paramorphisms with functions that are working on lists, one need to have access to paramorphisms \emph{for lists}. Moreover, these paramorphisms must be expressed with \minline{foldr}, since we want to preserve list-fusion with the \verb|"foldr/build"| rule. The solution is to give a copy of the structure at each steps. Sadly, this definition is not what we need. Indeed, imagine that you want, for example, produce a fixed-point list from a classical list, but allowing fusion with \emph{both} list producers and \minline{List} consumers, you will have to do something like:
\begin{minted}{Haskell}
fromClassicalList :: [a] -> List a
fromClassicalList xs = 
  buildR $ \(Right u) -> snd $
    foldr 
      (\x (xs,y) -> 
        (cons x xs, u $ ConsF x $ (xs,y)))
      (nil,(u NilF))
    xs
\end{minted}
Excuse the non-exhaustive pattern matching, this is the only interesting case. So the obvious problem is that, even if \minline{u} is guaranteed to not use both the not-consumed structure and the recursive call, they need to be both available. The medication is here worth than the disease, and if we perform fusion with lists, we must do it with, for now, only catamorphisms.
% + TODO relire papier PeytonJones (playing by the rules)
