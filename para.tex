%!TEX root = fusion.tex
\subsection{Paramorphisms}
\label{sec:para-list}

As far as we did, we worked only on catamorphisms. These are not really satisfying to define recursive functions that also use the unconsumed part of the structure. A \emph{paramorphism} (introduced by Meertens \cite{Meertens1992}) are a direct response, as it allows the combination function to have a look on the unconsumed part of the structure (imitating the full power of recursion).

They can be defined for lists using \minline{para}
\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para _ z []     = z
para k z (x:xs) = k x xs (para k z xs)
\end{minted}

Again, we can also express paramorphisms with types defined in terms of \minline{Fix}, but using a little trick: The usual way (as in the \verb|recursion-schemes| package \cite{ekmett:eschems}) is with \minline{para}:
\begin{minted}{Haskell}
para :: Functor f =>
  (f (Fix f, a) -> a) -> Fix f -> a
para f = c
  where
    c (Fix x) = f (fmap (\y -> (y,p y)) x)
\end{minted}

\noindent What is happening here? As with \minline{cata}, when we are trying to destruct a recursive structure, we are doing the recursive step plus giving a copy of the original data.
For example, we can encode a classic paramorphism, which is giving the list of proper suffixes of a list:
\begin{minted}{Haskell}
suff :: List a -> List (List a)
suff = para go
  where
    go NilF = nil
    go (ConsF x (xs,b)) = cons (cons x xs) b
\end{minted}

\subsection{Fusion for paramorphisms}

Now consider the less trivial paramorphism \minline{has2Leaves} which search in a binary tree if there is two distinct leaves defined in figure \ref{fig:has2Leaves}.

Imagine you are composing it with a \minline{mapt} operation (as defined in section \ref{fig:has2Leaves}). Then
the function:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v f = has2leaves u v . maptf
\end{minted}
\noindent is equivalent to:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v t f = Edge == para go t
  where
    go EmptyF    = Miss
    go (LeafF x) =
      if f x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if cata go' b then Edge else Tail
        Edge -> Edge
    go' EmptyF      = False
    go' (LeafF x)   = f x == v
    go' (NodeF a b) = a || b
\end{minted}

Can we generalize the work made in section \ref{sec:rectypes} to make this work? The answer is yes (section \ref{sec:para-impl}), but we first need to really se what we just made.

\begin{figure}
\begin{minted}{Haskell}
data Hit = Miss | Tail | Edge
  deriving (Eq, Ord, Show)

hasLeaf :: Eq a => a -> Tree a -> Bool
hasLeaf s = cata go
  where
    go EmptyF      = False
    go (LeafF x)   = x == s
    go (NodeF a b) = a || b

has2Leaves :: Eq a => a -> a -> Tree a -> Bool
has2Leaves u v = (==) Edge . para go
  where
    go EmptyF = Miss
    go (LeafF x) =
      if x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if hasLeaf v b then Edge else Tail
        Edge -> Edge

mapt :: (a -> b) -> Tree a -> Tree b
mapt f t = bind t (\x -> fix (LeafF f x))
\end{minted}
\caption{Functions on trees}
\label{fig:has2Leaves}
\end{figure}

\subsection{Usability and validity}
As noticed DomÃ­nguez et al. \cite{paramorphismFusion} fusing paramorphisms with other things is not always a good idea. Consider the previous example example with proper suffixes of a list, but again composed with a map:
\begin{minted}{Haskell}
suff (map f xs)
\end{minted}
\noindent If we try to fuse the two functions, we have
\begin{minted}{Haskell}
let go x =
  case x of
    NilF -> nil
    ConsF x (xs,b) -> 
      cons (map f (cons x xs)) b
  in para go xs
\end{minted}
\noindent The \minline{map} happen for each suffixes! We clearly not want that.
The problem here is that the combination function used \emph{both} the recursive call and the unconsumed part of the structure, which leads to a duplication of the work.

\subsection{Implementation}
\label{sec:para-impl}

It is well known that every catamorphism is a paramorphism where the combination function just don't use the un-consumed structure. Indeed, you can define \minline{cata} as:
\begin{minted}{Haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata go = para (go . fmap snd)
{-# INLINE cata #-}
\end{minted}

\noindent We can then define a rule that will only target paramorphisms. However, paramorphism fusion is not as classy as the catamorphisms one. This solution implies two main problems:
\begin{itemize}
\item We cannot target \minline{cata coerce}, since \minline{cata} is just \minline{para}. We cannot either target\\ \minline{para (coerce . fmap snd)}, since \minline{fmap} is a class function.

\item It is not compatible with GHC's \minline{build}. This is discussed in section \ref{sec:parabuild}.
\end{itemize}

We consequently choose to target a specific function that represent either a catamorphism or a paramorphism, called \minline{destruct} (defined in figure \ref{fig:para}). This choice has some consequences, each described below:

\begin{figure}
\begin{minted}{Haskell}
type Combi f a =
  Either (f a -> a) (f (Fix f, a) -> a)
  
type Para f = forall a. Combi f a -> a 

destruct :: Functor f => Combi f a -> Fix f -> a
destruct (Left c)  = cata c
destruct (Right c) = para c
{-# INLINE [1] destruct #-}

buildR :: Functor f => Para f -> Fix f
buildR g = g (Left fix)
{-# INLINE [1] buildR #-}

{-# RULES
"cata/buildR" [~1] forall f (g::Para f).
  cata f (buildR g) = g (Left f)

"para/buildR" [~1] forall f (g::Para f).
  para f (buildR g) = g (Right f)

"destruct/buildR" [~1] forall f (g::Para f).
  destruct f (buildR g) = g f

"cata/id"
  cata coerce = id
#-}

\end{minted}
\caption{The rule system for paramorphism fusion}
\label{fig:para}
\end{figure}

\subsubsection{Many rules}
We now have three rules, and we need all of them. Indeed, rules \verb|"cata/buildR"| and \verb|"para/buildR"| are needed to correctly fuse the two recursion schemes. \verb|"destruct/buildR"| is a rule needed when composing functions: with an expression like
\begin{minted}{Haskell}
map g (map f xs)
\end{minted}
\noindent The two \minline{map} will be inlined into it's \minline{buildR} form, but since they have to deal with either a paramorphism or a catamorphism, they need to use \minline{destruct} TODO explain more.

\subsubsection{For the user, the example of bind on binary trees}
Let us take back our \minline{has2leaves} example. If we want to have \minline{hasLeaf} fused with a possible previous operation on the tree (like a bind), we need to have not only \minline{bind} on a re-writable form, but also need that the transformation of the combination function's arguments to be in a re-writable form. TODO
\begin{figure}
\begin{minted}{Haskell}
bind :: TODO
bind f t = buildR $ \u -> destruct (
  case u of
    Left u -> Left $ \x -> 
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u $ NodeF a b)
    Right u -> Right $ \x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> para u (f x)
        NodeF (a,a') (b,b') -> 
        u $ NodeF (bindR f a,a') (bindR f b, b'))
  t

bindR :: TODO
bindR f t = buildR $ \u -> destruct (
  case u of
    Left u -> Left $ \x -> 
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u $ NodeF a b)
    Right u -> Right $ \x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> para u (f x)
        NodeF (a,a') (b,b') -> 
        u $ NodeF (cata go a,a') (cata go b, b'))
  t
  where
    go EmptyF = fix EmptyF
    go (LeafF a) = f a
    go (NodeF a b) = fix (NodeF a b)

\end{minted}
\caption{bind in term of buildR and destruct}
\label{fig:bindbuild}
\end{figure}

\subsubsection{Compatibility with GHC's rules on lists}
\label{sec:parabuild}
To be able to fuse eligible paramorphisms with functions that are working on lists, one need to have access to paramorphisms \emph{for lists}. Moreover, these paramorphisms must be expressed with \minline{foldr}, since we want to preserve list-fusion with the \verb|"foldr/build"| rule. Hence the following definition:
\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para f n = snd . 
  foldr (\x (xs,b) -> (x:xs, f x xs b)) ([],n)
\end{minted}
\noindent We just give a copy of the structure at each steps. Sadly, this definition is not what we need.TODO
We must, for now, resign ourselves to to not fuse a list construction with a paramorphism.
% + TODO relire papier PeytonJones (playing by the rules)
