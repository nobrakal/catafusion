%!TEX root = fusion.tex

\subsection{Introduction}
As pointed out in the precedent section, the \verb|Fix| method is not ideal at all and prevent some deforestation to be made.
However, we can do these optimizations for recursive functions, and we will show how. Note that this method can virtually be adjusted to any recursive type.

As an example, we will be working on algebraic graphs, developed by Mokhov \cite{Mokhov:2017:AGC:3156695.3122956}.
\begin{minted}{Haskell}
data Graph a =
    Empty
  | Vertex a
  | Overlay (Graph a) (Graph a)
  | Connect (Graph a) (Graph a)
\end{minted}

We give a part of the API in figure \ref{fig:alga}.
\begin{itemize}
	\item Catamorphisms can be defined using \minline{foldg}
	\item Paramorphisms can be defined using \minline{paragraph}
\end{itemize}

This is exactly what we wanted and better than if made with \minline{Fix} in section \ref{sec:para-rec} for paramorphisms: combinations functions \minline{o} and \minline{c} have a direct access of the unconsumed part of the structure.

\input{algaApi.tex}


\subsection{The case of hasEdge}
This function allows us to define an useful paramorphism on graphs, the \minline{hasEdge} function that test if an edge is in a graph (defined in figure \ref{fig:alga}). Note that this function is \emph{strictly} a paramorphism: it uses directly an unconsumed part of the graph (inside \minline{c}).

Now consider the following expression:
\begin{minted}{Haskell}
hasEdge s t (bind f g)
\end{minted}

It feels that deforestation can happen, and convert this expression to
\begin{minted}{Haskell}
(paragraph e v o c g) == Edge
  where
    e = Miss
    v x = if f x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
      Miss -> y
      Tail ->
        if foldg False (\x -> f x == t) (||) (||) y
        then Edge
        else Tail
      Edge -> Edge
\end{minted}

The next section will show that this is possible for a strict subclass of paramorphisms and section \ref{sec:defor-para} will show a possible implementation.

\subsection{What can we fuse}

As denoted by DomÃ­nquez and al. \cite{paramorphismFusion} TODO SECTION, we have to be careful when trying to do fusion on paramorphism.
This is easily viewed on an example. Consider the following expression, using para for lists as defined in \ref{sec:defi}:
\begin{minted}{Haskell}
para
  (\x xs acc -> x + (sum xs) + acc)
  (map (+ 1) list)
\end{minted}

One can think that this is a good idea to fuse the list traversal of \minline{map} with the destruction of \minline{para}. Sadly, this leads to an issue:

\begin{minted}{Haskell}
para
  (\x xs acc -> (x + 1) + (sum (map +1 xs)) + acc)
  list
\end{minted}

The \minline{+ 1} operation was duplicated! It is applied in the body of the combination function \emph{plus} on the unconsumed part of the list. Consequently, the \minline{+ 1} operation will be calculated twice to all the element of the list (except the head).

This disastrous result (imagine that the \minline{+ 1} operation is replaced by a costly one) yields to a necessary restriction of what we can fuse with a paramorphism:
The combination function need to only use \emph{either the result of the recursive call or the unconsumed part}.

This can be guaranteed restraining the type of the combinations functions of \minline{paragraph} to ensure that combinations functions \emph{does not} use both the recursive call and the unconsumed part of the structure.

\subsection{Implementation}

Let us try to do this for \minline{Graph}.
One possibility is to use a type
\begin{minted}{Haskell}
type Combination a b =
  Either
    (b -> (b -> b) (Graph a -> b))
    (Graph a -> (b -> b) (Graph a -> b))
\end{minted}

That either use the left recursive call and decide to use the right recursive call or the right unconsumed part of the graph, or use the left unconsumed part and decide to use either the right recursive call or the right unconsumed part.

Sadly, this type "encapsulate" the work made on both graphs part TODO EXPLAIN WHY, AND WHY IT IS A PROBLEM

So we will use a less classy approach, but a working one, the \minline{Combination} data defined in figure \ref{fig:parafus}. This is a sum-type that encodes three possibilities with three constructors:
\begin{itemize}
\item[\minline{B.}] To encode combination functions of type \minline{(b -> b -> b)}, that is, combination functions that could work for \minline{foldg}.
\item[\minline{L.}] To encode a function that first uses the left recursive call to decide (using a predicate) if it uses the right recursive call or the right unconsumed graph.
\item[\minline{R.}] To encode a function that first uses the left unconsumed part to decide (using a predicate) if it uses the right recursive call or the right unconsumed graph.
\end{itemize}

This effectively encodes the property we want to impose on function to fuse them. Moreover, this data-type allows us to define a function \minline{switchCombi} (defined in figure \ref{fig:parafus}) that transform a \minline{(Combination a b)} into a real combination function for \minline{paragraph}. This is done by a "frontend" function called \minline{paragraphR} (defined in figure \ref{fig:parafus}.

\subsection{Deforestation for paramorphisms}
\label{sec:defor-para}

We will again adapt the work of of Gill and al. \cite{Gill:1993:SCD:165180.165214}, this time for paramorphisms. We introduce \minline{buildR} (in figure \ref{fig:parafus}) that, similarly to \minline{build}, encode a graph-producing function but this time \emph{using a restricted paramorphism}.

We have now two rules, one to fuse \minline{foldg} and \minline{buildR} and an other to fuse \minline{paragraphR} and \minline{buildR}.



\input{rules.tex}
