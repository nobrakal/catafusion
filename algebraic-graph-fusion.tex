\documentclass[sigplan]{acmart}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{minted}

%
% defining the \BibTeX command - from Oren Patashnik's original BibTeX documentation.
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Rights management information. 
% This information is sent to you when you complete the rights form.
% These commands have SAMPLE values in them; it is your responsibility as an author to replace
% the commands and values with those provided to you when you complete the rights form.
%
% These commands are for a PROCEEDINGS abstract or paper.
\copyrightyear{2019}
\acmYear{2019}
%\setcopyright{acmlicensed}
\acmConference[]{}{}{}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection, June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmDOI{10.1145/1122445.1122456}
%\acmISBN{978-1-4503-9999-9/18/06}

\begin{document}
\title{Cata Fusion}
\author{Alexandre Moine}
\email{alexandre@moine.me}

\affiliation{%
	\institution{UniversitÃ© Paris Diderot}
	\streetaddress{5 Rue Thomas Mann}
	\city{Paris}
	\country{France}
	\postcode{75013}
}

\begin{abstract}
\end{abstract}
	
%
% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
TODO
\end{CCSXML}
	
%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}
	
%
% Keywords. The author(s) should pick words that accurately describe the work being
% presented. Separate the keywords with commas.
	
\keywords{Haskell, GHC, deforestation, algebraic graphs, TODO}
	
%
% This command processes the author and affiliation and title information and builds
% the first part of the formatted document.
\maketitle

\section{Introduction}
	
\section{Recursion schemes}
\subsection{Catamorphisms and paramorphisms}
Catamorphisms were introduced to reason on function that generalize a fold on a recursive structure.
They were first introduced by TODO and popularized by Meijer and al. \cite{4cec4a43c86444479dc0003182424795}.

\subsection{Anamorphisms and apomorphisms}

\subsection{Fusion of recursive scheme - hylomorphisms}
TODO

\subsection{Deforestation}
Deforestation is a process first introduced by Wadler \cite{WADLER1990231} and realized in Haskell by Gill and al. \cite{Gill:1993:SCD:165180.165214}

\section{Recursive types}
Recursive types can be defined as \emph{least fixed point} TODO REF
\begin{minted}{Haskell}
newtype Fix f = Fix (f (Fix f))
\end{minted}
This fixed point operator needs to use a \verb|newtype| since it calls itself, but the work of TODO will optimize this use.

For example, you define the following types:
\begin{minted}{Haskell}
data ListF a b =
    Nil
  | Cons a b
  
data TreeF a b =
    EmptyF
  | LeafF a
  | NodeF b b
  
type List a = Fix (ListF a)
type Tree a = Fix (Tree a)
\end{minted}

The definition of a type in term of \verb|Fix| allows a straightforward implementation of \verb|cata|:
\begin{minted}{Haskell}
cata :: Functor f => (f b -> b) -> Fix f -> b
cata f = c where c = f . fmap c . unfix
\end{minted}

\section{Going further with algebraic graphs}
As pointed out in TODO, the \verb|Fix| method is not ideal at all and prevent some deforestation to be made.
However, we can do these optimizations for recursive functions, and we will show how.

As an example, we will be working on algebraic graphs, REF
\begin{minted}{Haskell}
data Graph a =
    Empty
  | Vertex a
  | Overlay (Graph a) (Graph a)
  | Connect (Graph a) (Graph a)
\end{minted}

Catamorphisms can be easily defined for algebraic graphs, using REF:
\begin{minted}{Haskell}
foldg :: b -> (a -> b)
      -> (b -> b -> b)  -> (b -> b -> b) 
      -> Graph a -> b
foldg e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o (go a) (go b)
    go (Connect a b) = c (go a) (go b)
\end{minted}

Paramorphisms can be defined following almost the same way:
\begin{minted}{Haskell}
paragraph :: b -> (a -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> Graph a -> b
paragraph e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o a b (go a) (go b)
    go (Connect a b) = c a b (go a) (go b)
\end{minted}

This function allows us to define a useful paramorphism on graphs, the \verb|hasEdge| function that test if an edge is in a graph:

\begin{minted}{Haskell}
hasEdge :: Eq a => a -> a -> Graph a -> Bool
hasEdge s t g = (paragraph e v o c) == Edge
  where
    e = Miss
    v x = if x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
       Miss -> y
       Tail -> if hasVertex t b then Edge else Tail
       Edge -> Edge
\end{minted}

Note that this function is \emph{strictly} a paramorphism: it uses directly an unconsumed part of the graph.

\begin{acks}
TODO
\end{acks}
	

\bibliographystyle{ACM-Reference-Format}
\bibliography{publications}
\end{document}
