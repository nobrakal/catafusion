%!TEX root = fusion.tex
\subsection{Paramorphisms}

As far as we did, we worked only on catamorphisms. These are not really satisfying to define recursive functions that also use the unconsumed part of the structure. A \emph{paramorphism} (introduced by Meertens \cite{Meertens1992}) are a direct response, as it allows the combination function to have a look on the unconsumed part of the structure (imitating the full power of recursion).

They can be defined for lists using \minline{para}
\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para _ z []     = z
para k z (x:xs) = k x xs (para k z xs)
\end{minted}

Again, we can also express paramorphisms with types defined in terms of \minline{Fix}, but using a little trick: The usual way (as in the \verb|recursion-schemes| package \cite{ekmett:eschems}) is with \minline{para}:
\begin{minted}{Haskell}
para :: Functor f =>
  (f (Fix f, a) -> a) -> Fix f -> a
para f = c
  where
    c (Fix x) = f (fmap (\y -> (y,p y)) x)
\end{minted}

What is happening here? As with \minline{cata}, when we are trying to destruct a recursive structure, we are doing the recursive step plus giving a copy of the original data.
For example, we can encode a classic paramorphism, which is giving the list of proper suffixes of a list:
\begin{minted}{Haskell}
suff :: List a -> List (List a)
suff = para go
  where
    go NilF = nil
    go (ConsF x (xs,b)) = cons (cons x xs) b
\end{minted}

\subsection{Fusion for paramorphisms}

Now consider the less trivial paramorphism \minline{has2Leaves} which search in a binary tree if there is two distinct leaves defined in figure \ref{fig:has2Leaves}.

Imagine you are composing it with a \minline{mapt} operation (as defined in section \ref{fig:has2Leaves}). Then
the function:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v f = has2leaves u v . maptf
\end{minted}
\noindent is equivalent to:
\begin{minted}{Haskell}
has2LeavesBind :: Eq b =>
  b -> b -> (a -> b) -> Tree a -> Bool
has2LeavesBind u v t f = Edge == para go t
  where
    go EmptyF    = Miss
    go (LeafF x) =
      if f x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if cata go' b then Edge else Tail
        Edge -> Edge
    go' EmptyF      = False
    go' (LeafF x)   = x == v
    go' (NodeF a b) = a || b
\end{minted}

Can we generalize the work made in section \ref{sec:rectypes} to make this work?

\begin{figure}
\begin{minted}{Haskell}
data Hit = Miss | Tail | Edge
  deriving (Eq, Ord, Show)

hasLeaf :: Eq a => a -> Tree a -> Bool
hasLeaf s = cata go
  where
    go EmptyF      = False
    go (LeafF x)   = x == s
    go (NodeF a b) = a || b

has2Leaves :: Eq a => a -> a -> Tree a -> Bool
has2Leaves u v = (==) Edge . para go
  where
    go EmptyF = Miss
    go (LeafF x) =
      if x == u then Tail else Miss
    go (NodeF (_,a') (b,b')) =
      case a' of
        Miss -> b'
        Tail -> if hasLeaf t v then Edge else Tail
        Edge -> Edge

mapt :: (a -> b) -> Tree a -> Tree b
mapt f t = bind t (\x -> fix (LeafF f x))
\end{minted}
\caption{Functions on trees}
\label{fig:has2Leaves}
\end{figure}

\subsection{Validity}
As noticed DomÃ­nguez et al. \cite{paramorphismFusion} fusing paramorphisms with other things is not always a good idea. Consider the previous example example with proper suffixes of a list, but again composed with a map:
\begin{minted}{Haskell}
suff (map f xs)
\end{minted}
\noindent If we try to fuse the two functions, we have
\begin{minted}{Haskell}
let go x =
  case x of
    NilF -> nil
    ConsF x (xs,b) -> 
      cons (map f (cons x xs)) b
  in para go xs
\end{minted}
\noindent The \minline{map} happen for each suffixes! We clearly not want that.
The problem here is that the combination function used \emph{both} the recursive call and the unconsumed part of the structure, which leads to a duplication of the work.
\subsection{Implementation}
TODO
% + TODO relire papier PeytonJones (playing by the rules)