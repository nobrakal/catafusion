\documentclass[format=sigplan]{acmart}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{minted}
\newcommand{\minline}[1]{\mintinline{Haskell}{#1}}

%
% defining the \BibTeX command - from Oren Patashnik's original BibTeX documentation.
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Rights management information. 
% This information is sent to you when you complete the rights form.
% These commands have SAMPLE values in them; it is your responsibility as an author to replace
% the commands and values with those provided to you when you complete the rights form.
%
% These commands are for a PROCEEDINGS abstract or paper.
\copyrightyear{2019}
\acmYear{2019}
%\setcopyright{acmlicensed}
\acmConference[]{}{}{}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection, June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmDOI{10.1145/1122445.1122456}
%\acmISBN{978-1-4503-9999-9/18/06}

\begin{document}
\title{Cata Fusion}
\author{Alexandre Moine}
\email{alexandre@moine.me}

\affiliation{%
	\institution{Université Paris Diderot}
	\streetaddress{5 Rue Thomas Mann}
	\city{Paris}
	\country{France}
	\postcode{75013}
}

\begin{abstract}
\end{abstract}
	
%
% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
TODO
\end{CCSXML}
	
%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}
	
%
% Keywords. The author(s) should pick words that accurately describe the work being
% presented. Separate the keywords with commas.
	
\keywords{Haskell, GHC, deforestation, algebraic graphs, TODO}
	
%
% This command processes the author and affiliation and title information and builds
% the first part of the formatted document.
\maketitle

\section{Introduction}

A problem
An interesting one
An unsolved one
IDEA
	
\section{Recursion schemes}
Recursion schemes are almost everywhere in functional programming. They were popularized by Meijer and al. \cite{4cec4a43c86444479dc0003182424795}.

\subsection{Catamorphisms and paramorphisms}
A \emph{catamorphisms} generalize a fold on a recursive structure. For example, the catamorphism of lists is the so-called \minline{foldr}.
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go
  where
    go []     = z
    go (y:ys) = y `k` go ys

\end{minted}
TODO

A \emph{paramorphism} allow the combination function to have a look on the unconsummed part of the structure (imitating the full power of recursion). It can be defined for lists as

\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para k z = go
  where
    go []     = z
    go (y:ys) = k y ys (go ys)
\end{minted}

TODO equivalence para/foldr

\subsection{Anamorphisms and apomorphisms}
TODO

\subsection{Fusion of recursive scheme - hylomorphisms}
TODO

\subsection{Deforestation}
Deforestation is a process first introduced by Wadler \cite{WADLER1990231} and realized in Haskell by Gill and al. \cite{Gill:1993:SCD:165180.165214}. It is the idea that one can eliminate a structure produced by an anamorphism and destructed right away by a catamorphism.

The first example of this concept is the expression:
\begin{minted}{Haskell}
foldr c e (map f xs)
\end{minted}
\minline{map} will destruct the original list and produce a new one, which will be destructed after with \minline{foldr}.

Obviously, the above expression is equivalent to a more efficient one:
\begin{minted}{Haskell}
foldr (c . f) e xs
\end{minted}
The above expression will go through the list only once.

Note that the rewriting operation we made in this example is not at all dependent of the list structure: we just used the fact that we know how is made the list produced by \minline{map}. This concept can be simply generalized to recursive structure, as we will show in the next section.

\section{Deforestation on recursive types}
\subsection{Definition}
\label{sec:defi}
Recursive types can be defined as \emph{least fixed point} TODO REF, using the \minline{Fix} data-type:
\begin{minted}{Haskell}
newtype Fix f = Fix (f (Fix f))
\end{minted}
It is defined with the \minline{newtype} (and not simply by a type synonym) since it calls itself, but the work of Breitner and al \cite{Breitner:2014:SZC:2692915.2628141} will optimize this use.

For example, you define the following types:
\begin{minted}{Haskell}
data ListF a b =
    Nil
  | Cons a b
  
data TreeF a b =
    EmptyF
  | LeafF a
  | NodeF b b
  
type List a = Fix (ListF a)
type Tree a = Fix (Tree a)
\end{minted}

The definition of a type in term of \minline{Fix} allows a straightforward implementation of \minline{cata}, a high-order function for catamorphisms, provided that the fixed structure is a functor:
\begin{minted}{Haskell}
cata :: Functor f => (f b -> b) -> Fix f -> b
cata f = c where c = f . fmap c . unfix
\end{minted}

For example, \minline{(List a)} from the above example, one can write \minline{foldr}:
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr c e = cata go
  where
    go NilF = e
    go (ConsF a b) = c a b
\end{minted}

\subsection{The idea}
Deforestation can be implemented on recursive types imitating the work of Gill and al. \cite{Gill:1993:SCD:165180.165214}.

Applying a recursive structure to \minline{cata go} has just the effect to replace every occurrence of \minline{Fix} by \minline{go} in the structure. Consequently, the idea is to abstract structure-producing functions with respect to \minline{Fix}. This is done using \minline{buildR}.

\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b

buildR :: Cata f -> Fix f
buildR g = g Fix
\end{minted}

The argument of \minline{buildR} is TODO

Now, we have the lovely property that:
$$cata\ go\ (buildR\ g)\ =\ g\ go$$

This is exactly what we want: using the right-side of the equation \emph{does not}
build an intermediate structure.

\subsubsection{Validity}
Again, adapting the work of Gill and al. \cite{Gill:1993:SCD:165180.165214}, te validity of the above rule is guaranteed by the type.

\begin{theorem}
Using
\begin{itemize}
	\item $g : \forall\ b.\ (f b \to b) \to b$
	\item $go : f a \to a $
\end{itemize}
$$cata\ go\ (buildR\ g)\ =\ g\ go$$
\end{theorem}
\begin{proof}
	TODO
\end{proof}

\subsection{Implementation}
The implementation is pretty straightforward using GHC's rewrite rules described in \cite{pbr}. A rewrite rule consist in a name, maybe a phase to run and what to rewrite. TODO\\
GHC is performing 3 distinct phases where it tries to apply rewrite rules and it inlines (replace by its definition) functions. The so-called "phase control" is the \emph{only} mechanism that allows us to control when the rules are firing and when functions are inlined.

We want to have our rules compatible with those for lists already in place (the \verb|foldr/build| of \cite{Gill:1993:SCD:165180.165214}). They all target the \minline{bind} (defined in\verb|GHC.Base|) functions that is inlined in phase 1, so we have to do all our rewriting work before, in phase 2.

Fortunately, this is not very hard work. First of all, imitating again the work made for lists, we will add an 
\begin{minted}{Haskell}
{-# INLINE [1] buildR #-}
\end{minted}
pragma, to ensure that \minline{buildR} is not inlined too quickly. Note that we force the inlining by using \verb|INLINE| and not only \verb|NOINLINE|, but this is a good idea since high-order functions like \minline{buildR} generally benefit from inlining. 

Now, our rule will also target \minline{cata}, do we also add an \verb|INLINE| pragma to it.
\begin{minted}{Haskell}
{-# INLINE [0] cata #-}
\end{minted}

Now we can safely add the rule:
\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b
{-# RULES
"cata/buildR" forall (f :: t b -> b) (g :: Cata t).
  cata f (buildR g) = g f
 #-}
\end{minted}
This rule is genuinely replacing all occurrences of \minline{cata f (buildR g)} by \minline{g f} \emph{when types matches}, that is when the argument of \minline{buildR} are allowing fusion.

\subsection{Rewrite unneeded destructions}
All our work if focused on destructing structures. It is working great but can have unwanted implications. Consider the following code, implementing \minline{bind} for recursive trees:

\begin{minted}{Haskell}
bind :: (a -> Tree b) -> Tree a -> Tree b
bind f t = buildR
  (\u -> cata
    (\x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u (NodeF a b))
    t)
\end{minted}

So given a \minline{u} (which without rewriting will be \minline{Fix}), you can indeed go trough the tree until you find a leaf, and replace this leaf by an application of a function producing a tree (here called \minline{f}). But why do we need the unneeded \minline{cata u} after? Because we can replace \minline{u} by an other function than \minline{Fix} TODO EXPLAIN MORE.

The solution is to use a second rewriting rule that get rid of the identity catamorphism. Due to the work of Breitner and al. \cite{Breitner:2014:SZC:2692915.2628141} we cannot target \minline{Fix} in our rewrite rule since it will be optimized away. Fortunately, this use case was planned and we can target the function that replace \minline{Fix}: \minline{coerce}.

\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b
{-# RULES
"cata/id" forall (g :: Fix f)
  cata coerce g = g
#-}
\end{minted}

\subsection{Example}
The \verb|foldr/build| rule is now just a particular case, using:
\begin{minted}{haskell}
map :: (a -> b) -> List a -> List b
map f xs = buildR 
  (\n ->
    let go x = case x of
      NilF -> n NilF
      ConsF a b -> n (ConsF (f a) b) in
    cata go xs)
\end{minted}

The expression
\begin{minted}{Haskell}
	foldr c e (map f xs)
\end{minted}
(with \minline{foldr} defined as in section \ref{sec:defi}) will first be rewritten (only by inlining) as:
\begin{minted}{haskell}
cata go' (buildR 
  (\n ->
    let go x = case x of
      NilF -> n NilF
      ConsF a b -> n (ConsF (f a) b) in
    cata go xs))
\end{minted}

With the \verb|cata/buildR| this will be rewritten to:
\begin{minted}{haskell}
let go x = case x of
  NilF -> go' NilF
  ConsF a b -> go' (ConsF (f a) b) in
cata go xs
\end{minted}

\subsection{Paramorphism for recursive types}
\label{sec:para-rec}
As far as we did, we worked only on catamorphisms. How can we implement paramorphisms?

The usual way is with \minline{para}:
\begin{minted}{Haskell}
para ::
  Functor f => (f (Fix f, a) -> a) -> Fix f -> a
para t = p
  where
    p = t . fmap ((,) <*> p) . unfix
\end{minted}

\section{Going further with algebraic graphs}
As pointed out in TODO, the \verb|Fix| method is not ideal at all and prevent some deforestation to be made.
However, we can do these optimizations for recursive functions, and we will show how.

As an example, we will be working on algebraic graphs, REF
\begin{minted}{Haskell}
data Graph a =
    Empty
  | Vertex a
  | Overlay (Graph a) (Graph a)
  | Connect (Graph a) (Graph a)
\end{minted}

Catamorphisms can be easily defined for algebraic graphs, using REF:
\begin{minted}{Haskell}
foldg :: b -> (a -> b)
      -> (b -> b -> b)  -> (b -> b -> b) 
      -> Graph a -> b
foldg e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o (go a) (go b)
    go (Connect a b) = c (go a) (go b)
\end{minted}

Paramorphisms can be defined following almost the same way:
\begin{minted}{Haskell}
paragraph :: b -> (a -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> Graph a -> b
paragraph e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o a b (go a) (go b)
    go (Connect a b) = c a b (go a) (go b)
\end{minted}

This is exactly what we wanted and better than if made with \minline{Fix} in section \ref{sec:para-rec}: combinations functions \minline{o} and \minline{c} have a direct access of the unconsumed part of the structure.

\subsection{The case of hasEdge}

This function allows us to define an useful paramorphism on graphs, the \minline{hasEdge} function that test if an edge is in a graph:

\begin{minted}{Haskell}
hasEdge :: Eq a => a -> a -> Graph a -> Bool
hasEdge s t g = (paragraph e v o c g) == Edge
  where
    e = Miss
    v x = if x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
       Miss -> y
       Tail -> if hasVertex t b then Edge else Tail
       Edge -> Edge
\end{minted}

Note that this function is \emph{strictly} a paramorphism: it uses directly an unconsumed part of the graph (inside \minline{c}).

Now consider the following expression:
\begin{minted}{Haskell}
hasEdge s t (bind f g)
\end{minted}

\begin{figure*}
\begin{minted}{Haskell}
instance Functor Graph where
  fmap f = foldg Empty (Vertex . f) Overlay Connect

instance Applicative Graph where
  pure = Vertex
  (<*>) = f >>= (<$> x)

instance Monad Graph where
  return = pure
  g (>>=) f = foldg Empty f Overlay Connect
  
hasEdge :: Eq a => a -> Graph a -> Bool
hasEdge s = foldg False ((==) s) (||) (||)
\end{minted}
\caption{A part of the Alga API}
\end{figure*}


It feels that deforestation can happen, and convert this expression to
\begin{minted}{Haskell}
(paragraph e v o c g) == Edge
  where
    e = Miss
    v x = if f x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
      Miss -> y
      Tail ->
        if foldg False (\x -> f x == t) (||) (||) y
        then Edge
        else Tail
      Edge -> Edge
\end{minted}

The next section will show that this is possible for a strict subclass of paramorphisms, and section \ref{sec:defor-para} will show a possible implementation.

\subsection{What can we fuse}

As denoted by Domínquez and al. \cite{paramorphismFusion}, we have to be careful when trying to do fusion on paramorphism.
This is easily viewed on an example. Consider the following expression, using para for lists as defined in \ref{sec:defi}:
\begin{minted}{Haskell}
para
  (\x xs acc -> x + (sum xs) + acc)
  (map (+ 1) list)
\end{minted}

One can think that this is a good idea to fuse the list traversal of \minline{map} with the destruction of \minline{para}. Sadly, this leads to an issue:

\begin{minted}{Haskell}
para
  (\x xs acc -> (x + 1) + (sum (map +1 xs)) + acc)
  list
\end{minted}

The \minline{+ 1} operation was duplicated! It is applied in the body of the combination function \emph{plus} on the unconsumed part of the list. Consequently, the \minline{+ 1} operation will be calculated twice to all the element of the list (except the head).

This disastrous result (imagine that the \minline{+ 1} operation is replaced by a costly one) yields to a necessary restriction of what we can fuse with a paramorphism:
The combination function need to only use \emph{either the result of the recursive call or the unconsumed part}.

This can be guaranteed restraining the type of the combinations functions of \minline{paragraph}.
TODO

\subsection{Deforestation for paramorphisms}
\label{sec:defor-para}
We will again adapt the work of of Gill and al. \cite{Gill:1993:SCD:165180.165214}, this time for paramorphisms.

\begin{acks}
TODO
\end{acks}
	

\bibliographystyle{ACM-Reference-Format}
\bibliography{publications}
\end{document}
