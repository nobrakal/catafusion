\documentclass[format=sigplan]{acmart}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{minted}
\newcommand{\minline}[1]{\mintinline{Haskell}{#1}}

%
% defining the \BibTeX command - from Oren Patashnik's original BibTeX documentation.
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Rights management information. 
% This information is sent to you when you complete the rights form.
% These commands have SAMPLE values in them; it is your responsibility as an author to replace
% the commands and values with those provided to you when you complete the rights form.
%
% These commands are for a PROCEEDINGS abstract or paper.
\copyrightyear{2019}
\acmYear{2019}
%\setcopyright{acmlicensed}
\acmConference[]{}{}{}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection, June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmDOI{10.1145/1122445.1122456}
%\acmISBN{978-1-4503-9999-9/18/06}

\begin{document}
\title{Cata Fusion}
\author{Alexandre Moine}
\email{alexandre@moine.me}

\affiliation{%
	\institution{UniversitÃ© Paris Diderot}
	\streetaddress{5 Rue Thomas Mann}
	\city{Paris}
	\country{France}
	\postcode{75013}
}

\begin{abstract}
\end{abstract}
	
%
% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
TODO
\end{CCSXML}
	
%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}
	
%
% Keywords. The author(s) should pick words that accurately describe the work being
% presented. Separate the keywords with commas.
	
\keywords{Haskell, GHC, deforestation, algebraic graphs, TODO}
	
%
% This command processes the author and affiliation and title information and builds
% the first part of the formatted document.
\maketitle

\section{Introduction}

A problem
An interesting one
An unsolved one
IDEA
	
\section{Recursion schemes}
Recursion schemes are almost everywhere in functional programming. They were popularized by Meijer and al. \cite{4cec4a43c86444479dc0003182424795}.

\subsection{Catamorphisms and paramorphisms}
A \emph{catamorphisms} generalize a fold on a recursive structure. For example, the catamorphism of lists is the so-called \minline{foldr}.
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
\end{minted}
TODO

\subsection{Anamorphisms and apomorphisms}
TODO

\subsection{Fusion of recursive scheme - hylomorphisms}
TODO

\subsection{Deforestation}
Deforestation is a process first introduced by Wadler \cite{WADLER1990231} and realized in Haskell by Gill and al. \cite{Gill:1993:SCD:165180.165214}. It is the idea that one can eliminate a structure produced by an anamorphism and destructed right away by a catamorphism.

The first example of this concept is the expression:
\begin{minted}{Haskell}
foldr c e (map f xs)
\end{minted}
\minline{map} will destruct the original list and produce a new one, which will be destructed after with \minline{foldr}.

Obviously, the above expression is equivalent to a more efficient one:
\begin{minted}{Haskell}
foldr (c . f) e xs
\end{minted}
The above expression will go through the list only once.

Note that the rewriting operation we made in this example is not at all dependent of the list structure: we just used the fact that we know how is made the list produced by \minline{map}. This concept can be simply generalized to recursive structure, and we will show in the next section.

\section{Deforestation on recursive types}
\subsection{Definition}
Recursive types can be defined as \emph{least fixed point} TODO REF, using the \minline{Fix} data-type:
\begin{minted}{Haskell}
newtype Fix f = Fix (f (Fix f))
\end{minted}
It is defined with the \minline{newtype} (and not simply by a type synonym) since it calls itself, but the work of TODO will optimize this use.

For example, you define the following types:
\begin{minted}{Haskell}
data ListF a b =
    Nil
  | Cons a b
  
data TreeF a b =
    EmptyF
  | LeafF a
  | NodeF b b
  
type List a = Fix (ListF a)
type Tree a = Fix (Tree a)
\end{minted}

The definition of a type in term of \minline{Fix} allows a straightforward implementation of \minline{cata}, a high-order function for catamorphisms, provided that the fixed structure is a functor:
\begin{minted}{Haskell}
cata :: Functor f => (f b -> b) -> Fix f -> b
cata f = c where c = f . fmap c . unfix
\end{minted}

For example, \minline{(List a)} from the above example, once can write \minline{foldr}:
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr c e = cata go
  where
    go NilF = e
    go (ConsF a b) = c a b
\end{minted}

\subsection{The idea}
Deforestation can be implemented on recursive types imitating the work of Gill and al. \cite{Gill:1993:SCD:165180.165214}.

Applying a recursive structure to \minline{cata go} has just the effect to replace every occurrence of \minline{Fix} by \minline{go} in the structure. Consequently, the idea is to abstract structure-producing functions with respect to \minline{Fix}. This is done using \minline{buildR}.

\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b

buildR :: Cata f -> Fix f
buildR g = g Fix
\end{minted}

Now, we have the lovely property that:
$$cata\ go\ (buildR\ g)\ =\ g\ go$$

This is exactly what we want: using the right-side of the equation \emph{does not}
build an intermediate structure.

\subsubsection{Validity}
Again, adapting the work of Gill and al. \cite{Gill:1993:SCD:165180.165214}, te validity of the above rule is guaranteed by the type.

\begin{theorem}
Using
\begin{itemize}
	\item $g : \forall\ b.\ (f b \to b) \to b$
	\item $go : f a \to a $
\end{itemize}
$$cata\ go\ (buildR\ g)\ =\ g\ go$$
\end{theorem}
\begin{proof}
	TODO
\end{proof}

\subsection{Implementation}
The implementation is pretty straightforward using GHC's rewrite rules described in \cite{pbr}. A rewrite rule consist in a name, maybe a phase to run and what to rewrite. TODO\\
GHC is performing 3 distinct phases where it tries to apply rewrite rules and it inlines (replace by its definition) functions. The so-called "phase control" is the \emph{only} mechanism that allows us to control when the rules are firing and when functions are inlined.

We want to have our rules compatible with those for lists already in place (the \verb|foldr/build| of \cite{Gill:1993:SCD:165180.165214}). They all target the \minline{bind} (defined in\verb|GHC.Base|) functions that is inlined in phase 1, so we have to do all our rewriting work before, in phase 2.

Fortunately, this is not very hard work. First of all, imitating again the work made for lists, we will add an 
\begin{minted}{Haskell}
{-# INLINE [1] buildR #-}
\end{minted}
pragma, to ensure that \minline{buildR} is not inlined too quickly. Note that we force the inlining by using \verb|INLINE| and not only \verb|NOINLINE|, but this is a good idea since high-order functions like \minline{buildR} generally benefit from inlining. 

Now, our rule will also target \minline{cata}, do we also add an \verb|INLINE| pragma to it.
\begin{minted}{Haskell}
{-# INLINE [0] cata #-}
\end{minted}

TODO WHY 0

Now we can safely add the rule:
\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b
{-# RULES
"cata/buildR" forall (f :: t b -> b) (g :: Cata t).
  cata f (buildR g) = g f
 #-}
\end{minted}
This rule is genuinely replacing all occurrences of \minline{cata f (buildR g)} by \minline{g f} \emph{when types matches}, that is when the argument of \minline{buildR} are allowing fusion.

\subsection{Rewrite unneeded destructions}
All our work if focused on destructing structures. It is working great but can have unwanted implications. Consider the following code, implementing \minline{bind} for recursive trees:

\begin{minted}{Haskell}
bind :: (a -> Tree b) -> Tree a -> Tree b
bind f t = buildR
  (\u -> cata
    (\x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u (NodeF a b))
    t)
\end{minted}

So given a \minline{u} (which without rewriting will be \minline{Fix}), you can indeed go trough the tree until you find a leaf, and replace this leaf by an application of a function producing a tree (here called \minline{f}). But why do we need the unneeded \minline{cata u} after? Because we can replace \minline{u} by an other function than \minline{Fix} TODO EXPLAIN MORE.

The solution is to use a second rewriting rule that get rid of the identity catamorphism. Due to the work of Breitner and al. \cite{Breitner:2014:SZC:2692915.2628141} we cannot target \minline{Fix} in our rewrite rule since it will be optimized away. Fortunately, this use case was planned and we can target the function that replace \minline{Fix}: \minline{coerce}.

\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b
{-# RULES
"cata/id" forall (g :: Fix f)
  cata coerce g = g
#-}
\end{minted}

\subsection{Examples}
TODO

\subsection{Paramorphism for recursive types}
\label{sec:para-rec}
As far as we did, we worked only on catamorphisms. How can we implement paramorphisms?

The usual way is with \minline{para}:
\begin{minted}{Haskell}
para :: Functor f => (f (Fix f, a) -> a) -> Fix f -> a
para t = p
  where
    p = t . fmap ((,) <*> p) . unfix
\end{minted}

\section{Going further with algebraic graphs}
As pointed out in TODO, the \verb|Fix| method is not ideal at all and prevent some deforestation to be made.
However, we can do these optimizations for recursive functions, and we will show how.

As an example, we will be working on algebraic graphs, REF
\begin{minted}{Haskell}
data Graph a =
    Empty
  | Vertex a
  | Overlay (Graph a) (Graph a)
  | Connect (Graph a) (Graph a)
\end{minted}

Catamorphisms can be easily defined for algebraic graphs, using REF:
\begin{minted}{Haskell}
foldg :: b -> (a -> b)
      -> (b -> b -> b)  -> (b -> b -> b) 
      -> Graph a -> b
foldg e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o (go a) (go b)
    go (Connect a b) = c (go a) (go b)
\end{minted}

Paramorphisms can be defined following almost the same way:
\begin{minted}{Haskell}
paragraph :: b -> (a -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> (Graph a -> Graph a -> b -> b -> b) 
          -> Graph a -> b
paragraph e v o c = go
  where
    go Empty = e
    go (Vertex x) = v x
    go (Overlay a b) = o a b (go a) (go b)
    go (Connect a b) = c a b (go a) (go b)
\end{minted}

This is exactly what we wanted and better than if made with \minline{Fix} in section \ref{sec:para-rec}: combinations functions \minline{o} and \minline{c} have a direct access of the unconsumed part of the structure.

\subsection{The case of hasEdge}

This function allows us to define an useful paramorphism on graphs, the \minline{hasEdge} function that test if an edge is in a graph:

\begin{minted}{Haskell}
hasEdge :: Eq a => a -> a -> Graph a -> Bool
hasEdge s t g = (paragraph e v o c g) == Edge
  where
    e = Miss
    v x = if x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
       Miss -> y
       Tail -> if hasVertex t b then Edge else Tail
       Edge -> Edge
\end{minted}

Note that this function is \emph{strictly} a paramorphism: it uses directly an unconsumed part of the graph (inside \minline{c}).

Now consider the following expression:
\begin{minted}{Haskell}
hasEdge s t (bind f g)
\end{minted}
TODO RECALL GRAPH INSTANCES
It feels that deforestation can happen, and convert this expression to
\begin{minted}{Haskell}
(paragraph e v o c g) == Edge
  where
    e = Miss
    v x = if f x == s then Tail else Miss
    o _ _ x y = case x of
      Miss -> y
      Tail -> max Tail y
      Edge -> Edge
    c _ b x y = case x of
      Miss -> y
      Tail ->
        if foldg False (\x -> f x == t) (||) (||) y
        then Edge
        else Tail
      Edge -> Edge
\end{minted}

The next section will show that this is possible for a strict subclass of paramorphisms, and section \ref{sec:defor-para} will show a possible implementation.

\subsection{What can we fuse}

\subsection{Deforestation for paramorphisms}
\label{sec:defor-para}
We will again adapt the work of of Gill and al. \cite{Gill:1993:SCD:165180.165214}, this time for paramorphisms.

\begin{acks}
TODO
\end{acks}
	

\bibliographystyle{ACM-Reference-Format}
\bibliography{publications}
\end{document}
