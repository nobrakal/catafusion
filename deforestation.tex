%!TEX root = fusion.tex

Deforestation is a process first introduced by Wadler \cite{WADLER1990231} and realized in Haskell by Gill et al. \cite{Gill:1993:SCD:165180.165214}. It is the idea that one can eliminate a structure produced by "good function" (like an anamorphism) and destructed right away by a catamorphism, since we know how the intermediate structure was built.

A first example of this concept is on lists with the expression:
\begin{minted}{Haskell}
map g (map f xs)
\end{minted}
\minline{map} will destruct the original list and produce a new one, which will be destructed right away by \minline{map}. It is easy to see that the above expression is equivalent to a more efficient one:
\begin{minted}{Haskell}
map (g . f) xs
\end{minted}
\noindent where we go through the list only once.
The rewriting operation we made in this example is again not at all dependent of the list structure: we just used the fact that we know how is made the list produced by \minline{map}. This concept can be simply generalized to recursive structure, as we will show in the next section.

\subsection{The idea}
Deforestation can be implemented on fixed-point types imitating the work of Gill et al. \cite{Gill:1993:SCD:165180.165214} on lists. Applying \minline{cata go} to a fixed-point structure has just the effect to replace every occurrence of \minline{Fix} by \minline{go}. Consequently, the idea is to abstract structure-producing functions with respect to \minline{Fix}. This is done using \minline{buildR}.

\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b

buildR :: Cata f -> Fix f
buildR g = g Fix
\end{minted}

\noindent Intuitively, the argument of \minline{buildR} is a function that can, for all type \minline{b}, and given something to "perform recursion" (that is, produce a \minline{b} from a \minline{(f b)}) can produce something of type \minline{b}. For example, you can use \minline{buildR} to define \minline{ana}:
\begin{minted}{Haskell}
ana :: Functor f => (b -> f b) -> b -> Fix f
ana f b = buildR
  (\u -> let c =  u . fmap c . f in c b)
\end{minted}

\subsubsection{Validity}
At first glance, we have the lovely property that:
$$cata\ go\ (buildR\ g)\ =\ g\ go$$

This is exactly what we want: the right-side of the equation \emph{does not} build an intermediate structure. The validity of the above rule is guaranteed by the type (more precisely the rank-2 one), but as we show in section \ref{sec:seq} it is a semantic equivalence valid only without the presence of \minline{seq} and \minline{undefined}.

\begin{theorem}
Using, for a fixed parametric type $F$, a valid instance of $Functor$, and a type $A$:
\begin{itemize}
	\item $g :: \forall\ B.\ (F\ B \to B) \to B$
	\item $go :: F\ A \to A $
\end{itemize}
$$cata\ go\ (buildR\ g)\ =\ g\ go$$
\end{theorem}
\begin{proof}
This is a consequence of free theorems of Wadler \cite{Wadler:1989:TF:99370.99404}, as for the \verb|foldr/build| rule \cite{Gill:1993:SCD:165180.165214}. The free theorem associated with $g$'s type is that, for all types $C$ and $D$, $f\ ::\ C \to D$, $p\ ::\ F\ C \to C$ and $q\ ::\ F\ D \to D$, then we have the following implication:
\begin{align*}
[\ \forall& x::C.\ f\ (p\ x)\ =\ q\ (fmap\ f\ x)\ ]\\
&\implies f\ (g\ p)\ =\ g\ q
\end{align*}
Now we can instantiate:
\begin{itemize}
	\item $C\ =\ Fix\ F$, $D\ =\ A$
	\item $f\ =\ cata\ go$
	\item $p\ =\ fix$
	\item $q\ =\ go$
\end{itemize}
then we have
\begin{align*}
&[\ \forall x::F\ (Fix\ F).\\
&cata\ go\ (fix\ x)\ =\ go\ (fmap\ (cata\ go)\ x)\ ]\\
&\implies cata\ go\ (g\ fix)\ =\ g\ go
\end{align*}
Given the definition of $cata$, the premise trivially holds, so we have the conclusion:
$$cata\ go\ (g\ fix)\ =\ g\ go$$
Given the definition of $buildR$, this is exactly what we required.
\end{proof}

\subsubsection{A note on $\bot$ and \minline{seq}}
\label{sec:seq}
Free theorems are known to (partially) fail in presence of $\bot$ (\minline{undefined} in Haskell) and \minline{seq}, defined in the Haskell report \cite{haskellReport} as a function respecting the following equation:
\begin{align*}
seq\ \bot\ b\ &=\ \bot\\
seq\ a\ b\ &=\ b\ \mathrm{,if}\ a\ \neq\ \bot
\end{align*}
\minline{seq} a function forcing the evaluation of its first argument and returning the second. This characterization is sufficient to break our rule (as it breaks also the \verb|foldr/build| one). Consider the following example:

\begin{minted}{Haskell}
data BinF a = L | R deriving (Functor)
type Bin = Fix BinF

bad :: Int
bad = cata go $ buildR $ \u -> u L `seq` u R
  where
    go L = undefined
    go R = 0
\end{minted}
\minline{Bin} is a non-recursive type with two constructors validly defined in terms of \minline{Fix} (which allow us to use \minline{cata} and \minline{buildR}). Now consider the \minline{bad} expression: it constructs a \minline{Bin} using \minline{R} and then destruct it, with a partial function, defined only for \minline{R}. Without rewrite rules, the function simply returns \minline{0} (since \minline{u} is replaced by \minline{Fix}). Now with our \verb|cata/buildR| rule, \minline{u} is replaced by \minline{go}, and we precisely force the definition of \minline{go} on \minline{L}, so the whole expression in now \minline{undefined}.

Fortunately, as noticed by Johann and Voigtländer \cite{JV04}, one can recover free theorems by requiring more properties on the combination function (like strictness and totality), but this is beyond our scope.

\subsection{Implementation}
The implementation is pretty straightforward using GHC's rewrite rules described in the great work of Peyton Jones et al. \cite{pbr}.

A rewrite rule consist in a name and body. The body is an equality were free variables are bounded by a universal quantifier. When the left part of the equality is encountered in the code (and types match), it is replaced by the right part (more details can be found on GHC's manual \cite{ghc:manual}).

A rewrite rule can also specify a phase constraint. GHC is performing 3 distinct phases where it tries to apply rewrite rules and it inlines (replace by its definition) functions. The so-called "phase control" is the \emph{only} mechanism that allows us to ensure when the rules are firing and when functions are inlined.

We want our rules to be compatible with those for lists already in place (the \verb|foldr/build| of Gill et al. \cite{Gill:1993:SCD:165180.165214}). They all target the \minline{build} (defined in \verb|GHC.Base|) function that is inlined in phase 1, so we have to do all our rewriting work before, in phase 2. Fortunately, this is not very hard work. First of all, imitating again the work made for lists, we will add a
\begin{minted}{Haskell}
{-# INLINE [1] buildR #-}
\end{minted}
pragma, to ensure that \minline{buildR} is not inlined too quickly. Note that we force the inlining by using \verb|INLINE| and not only \verb|NOINLINE|, but this is a good idea since high-order functions like \minline{buildR} generally benefit from inlining.

Our rule will also target \minline{cata}, we consequently also need to add an \verb|INLINE| pragma to it.
\begin{minted}{Haskell}
{-# INLINE [0] cata #-}
\end{minted}

\noindent We can now safely add the rule:
\begin{minted}{Haskell}
type Cata f = forall b. (f b -> b) -> b
{-# RULES
"cata/buildR" [~1]
  forall (f::t b -> b) (g::Cata t).
    cata f (buildR g) = g f
 #-}
\end{minted}
This rule is genuinely replacing all occurrences of\\ \minline{cata f (buildR g)} by \minline{g f} \emph{when types matches}, that is when the argument of \minline{buildR} are allowing fusion. The \minline{[~1]} parameter will disable the rule in the final phase, so we can rewrite un-merged functions back.

\subsubsection{The problem of inlining of recursive functions}
GHC is not (at all) very keen to inline recursive functions. Since we rewrite many things, there is sometimes an expression like:
\begin{minted}{Haskell}
cata go (fix x)
\end{minted}
ending up in the code, and will not be optimized to the equivalent
\begin{minted}{Haskell}
go x
\end{minted}
Fortunately, the work of Peyton Jones \cite{PeytonJones:2007:CSH:1291151.1291200} offers the needed optimizations, through call-pattern specialisation, enabled using the GHC's flag: \verb|-fspec-constr|.

\subsection{Rewrite unneeded destructions}
\label{sec:bind-def}
All our work if focused on destructing structures. It is working great but can have unwanted implications. Consider the following code, implementing \minline{bind} for recursive trees (as defined in figure \ref{fig:listtree}):

\begin{minted}{Haskell}
bind :: Tree a -> (a -> Tree b) -> Tree b
bind t f = buildR $ \u ->
  cata
    (\x ->
      case x of
        EmptyF -> u EmptyF
        LeafF x -> cata u (f x)
        NodeF a b -> u (NodeF a b))
    t
\end{minted}

\noindent Given a \minline{u} (which without rewriting will be \minline{Fix}), you can indeed go trough the tree until you find a leaf, and replace this leaf by an application of a function producing a tree (here called \minline{f}). But why do we need the unneeded \minline{cata u} after? Because one can replace \minline{u} by another function than \minline{Fix}, for example, something that calculate the number the leaves of the tree, thus we effectively need to "destruct" the tree constructed by \minline{f}, even if it induces an unwanted destruction/reconstruction without rewriting. The solution is to use a second rewrite rule that get rid of the identity catamorphism.

Due to the work of Breitner et al. \cite{Breitner:2014:SZC:2692915.2628141} we cannot target \minline{Fix} in our rewrite rule since it will be optimized away. Fortunately, this use case was planned (section 6.5 of the previously mentioned article) and we can target the function that replace \minline{Fix}: \minline{coerce}.

\begin{minted}{Haskell}
{-# RULES
"cata/id" forall (g :: Fix f)
  cata coerce g = g
 #-}
\end{minted}

\noindent As a side note, this little problem induces a possible limitation but easily solved: the real need for optimizations. Rewrite rules mechanism is enabled either when required by the user or where optimization is enabled (with \verb|-O| or \verb|-O2| flags); fortunately, \verb|cabal| enforces optimizations by default. If rewrite rules are not enabled, the direct use of \minline{build} in \minline{bind} body will introduce an unwanted and unneeded traversal of the part of the tree as showed. This is solved (and this is the solution taken by the \verb|GHC.Base| module), it to define "normally" \minline{bind}, and add a rewrite rule to rewrite it in its \minline{build} form.

Note also that, as Voigtländer \cite{Voigtlnder2008TypesFP} noticed for \minline{map}, \minline{bind} for \minline{Tree} is expressed both with \minline{buildR} and \minline{cata}, thus it can be fused with \emph{both} producers and consumers of trees.

\subsection{Examples}
\subsubsection{foldr/build}
The \verb|foldr/build| rule is now just a particular case, using:
\begin{minted}{haskell}
map :: (a -> b) -> List a -> List b
map f xs = buildR $ \u ->
  let go x = case x of
    NilF -> u NilF
    ConsF a b -> u (ConsF (f a) b)
  in cata go xs
\end{minted}

\noindent The expression:
\begin{minted}{Haskell}
foldr c e (map f xs)
\end{minted}
(with \minline{foldr} defined as in section \ref{subsec:defi}) is rewritten, only by inlining, as:
\begin{minted}{haskell}
cata go' $ buildR $ \u ->
  let go x = case x of
    NilF -> u NilF
    ConsF a b -> u (ConsF (f a) b)
  in cata go xs
\end{minted}

\noindent With the \verb|cata/buildR| rule this will be rewritten to:
\begin{minted}{haskell}
let go x = case x of
  NilF -> go' NilF
  ConsF a b -> go' (ConsF (f a) b)
in cata go xs
\end{minted}
That is exactly what we wanted!

\subsubsection{Automatic hylomorphisms}
We can define \minline{ana} in term of \minline{buildR}:
\begin{minted}{Haskell}
ana :: Functor f => (b -> f b) -> b -> Fix f
ana f b = buildR $ \u ->
  let c = u . fmap c . f in c b
\end{minted}

\noindent Then the fusion of a catamorphism composed with an anamorphism is automatic. In fact, this rule system allows optimization even if we are moving from some structures to some others: one can convert a list to a binary tree then reduce it to a boolean: it will, finally, only be a big catamorphism on the original list.

\subsection{Compatibility with GHC's rules on lists}
Our work is compatible with the one already made in the \verb|GHC.Base| and \verb|GHC.List| modules (described by Peyton Jones et al. \cite{pbr}) in the sense that one can write a function that destruct a (Prelude) list (using \verb|foldr| or any "good consumer" of lists) to a fixed-point structure \emph{that can be fused with list producers and fixed-point structure consumers}.

Let us take an example with \minline{Tree}, by defining\\ \minline{treeFromList} that convert a list to a "degenerated" tree, where each node has a leaf:
\begin{minted}{Haskell}
treeFromList :: [Tree a] -> Tree a
treeFromList xs = buildR $ \u ->
  foldr
    (\x -> u . NodeF (cata u x))
    (u EmptyF)
    xs
\end{minted}
\noindent \minline{treeFromlist} is made with both \minline{foldr} and \minline{buildR}, so it can fuse with both \minline{cata} or \minline{build}.

The reverse is also possible, for example to convert a fixed-point list to a Prelude one:
\begin{minted}{Haskell}
flistToList :: List a -> [a]
flistToList xs = GHC.Base.build $ \c n ->
  let go xs = case xs of
    NilF -> n
    ConsF a b -> c a b
  in cata go xs
\end{minted}
\noindent \minline{treeFromlist} is made with both \minline{cata} and \minline{build}, so it can fuse with both \minline{buildR} or \minline{foldr}.

It is simple to see that the system composed by \verb|cata/buildR| and \verb|foldr/build| rules is \emph{confluent}, that is, if there is an expression where both rules can fire, the order is not important (because both rules are just like a $\beta$-reduction with some manipulation of arguments).