%!TEX root = fusion.tex

Recursion schemes are almost everywhere in functional programming. They generalize a very common pattern: construct a structure and destruct it. They were popularized by Meijer et al. \cite{4cec4a43c86444479dc0003182424795}. TODO INTRODUCE MORE

\subsection{Catamorphisms and paramorphisms}
A \emph{catamorphism} generalize a fold on a recursive structure. For example, the catamorphism-maker of lists is the so-called \minline{foldr}.
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr k z = go
  where
    go []     = z
    go (y:ys) = y `k` go ys
\end{minted}
TODO

A \emph{paramorphism} (introduced by Meertens \cite{Meertens1992}) allow the combination function to have a look on the unconsumed part of the structure (imitating the full power of recursion). It can be defined for lists as

\begin{minted}{Haskell}
para :: (a -> [a] -> b -> b) -> b -> [a] -> b
para k z = go
  where
    go []     = z
    go (y:ys) = k y ys (go ys)
\end{minted}

TODO
\subsection{Anamorphisms and apomorphisms}
An \emph{anamorphism} generalize the notion of unfolding a recursive structure, that is, producing a structure from a seed value.
For example, the anamorphism-maker of lists is the so-called \minline{unfoldr}.
\begin{minted}{Haskell}
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr f = go
  where
    go b =
      case f b of
        Just (a, new_b) -> a `c` go new_b
        Nothing         -> n
\end{minted}
TODO

TODO apo
\subsection{Fusion of recursive schemes - hylomorphisms}
A first nice result TODO

\subsection{Fixed-point types}
\label{subsec:defi}
Recursive types can be defined as \emph{least fixed point} TODO REF, using the \minline{Fix} data-type:
\begin{minted}{Haskell}
newtype Fix f = Fix (f (Fix f))
\end{minted}
It is defined with the \minline{newtype} (and not simply by a type synonym) since it calls itself, but the work of Breitner et al. \cite{Breitner:2014:SZC:2692915.2628141} will optimize this use.

For example, you can define the following types:
\begin{minted}{Haskell}
data ListF a b =
    Nil
  | Cons a b

data TreeF a b =
    EmptyF
  | LeafF a
  | NodeF b b

type List a = Fix (ListF a)
type Tree a = Fix (Tree a)
\end{minted}

The definition of a type in term of \minline{Fix} allows a straightforward implementation of \minline{cata}, a high-order function for catamorphisms, provided that the fixed structure is a functor (we use the same definitions as E. Kmett in his \verb|recusrion-schemes| package \cite{ekmett:eschems}):
\begin{minted}{Haskell}
cata :: Functor f => (f b -> b) -> Fix f -> b
cata f = c where c = f . fmap c . unfix
\end{minted}

For example, \minline{(List a)} from the above example, one can write \minline{foldr}:
\begin{minted}{Haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr c e = cata go
where
go NilF = e
go (ConsF a b) = c a b
\end{minted}